unit DemoSimInput;

(*
DemoSimInput.pas
----------------
Begin: 2008/12/11
Last revision: $Date: 2009-10-27 21:19:34 $ $Author: areeves $
Version: $Revision: 1.7 $
Project: APHI Delphi Library for Simulation Modeling: Demo application
Website: http://www.naadsm.org/opensource/libaphi/
Author: Aaron Reeves <Aaron.Reeves@colostate.edu>
--------------------------------------------------
Copyright (C) 2008 - 2009 Animal Population Health Institute, Colorado State University

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General
Public License as published by the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
*)


interface

  uses
    // APHI General Purpose Delphi Library
    MyDelphiArrayUtils,
    FunctionPointers,

    // APHI Delphi Library for Simulation Modeling
    SimInput, // The base class

    // Application-specific units
    DemoModel
  ;


  // This class is slightly misnamed.  It contains not only the
  // simulation inputs (the PDFs used for the model and all of the other paramters),
  // but also includes the output generated by the model.
  type TDemoSimInput = class( TSimInput )
    protected
      _model: TDemoModel;

      _output: TARIntArray;

      procedure fillFnDictionary();

      procedure setUpdated( val: boolean ); override;
      
    public
      constructor create();
      destructor destroy(); override;

      function validate( err: PString = nil ): boolean; override;

      procedure run( fn: TObjFnVoid0 = nil ); override;

      property model: TDemoModel read _model;
      property output: TARIntArray read _output;
    end
  ;
  
  
implementation

  uses
    // Standard Delphi units
    SysUtils,

    // APHI General Purpose Delphi Library
    DebugWindow,
    I88n,
    MyStrUtils,

    // APHI Delphi Library for Simulation Modeling
    AphiRng,
    ChartFunction,
    ProbDensityFunctions,
    FunctionDictionary,
    
    // Application-specific units
    FunctionEnums
  ;


  constructor TDemoSimInput.create();
    begin
      inherited create();
      
      simIterations := 5;
      
      _model := TDemoModel.create( self );

      // _fnDictionary is created by the inherited constructor,
      // but default values are created here.
      fillFnDictionary();
    end
  ;


  destructor TDemoSimInput.destroy();
    begin
      freeAndNil( _model );

      // _fnDictionary is freed by the inherited destructor.
      inherited destroy();
    end
  ;
  
  
  procedure TDemoSimInput.fillFnDictionary();
    var
      fn: TPdfDiscreteUniform;
      item: TFunctionDictionaryItem;
    begin
      // Default distribution for PDF #1
      fn := TPdfDiscreteUniform.create( 1, 6, UUnitless );
      fn.dbField := integer( DEMOPdf1 );
      fn.name := 'Probability density function #1';
      fn.id := 1;

      item := TFunctionDictionaryItem.create( fn );
      item.new := true;
      _fnDictionary.insert( fn.name, item );

      _model.pdf1Name := fn.name;

      // Default distribution for PDF #2
      fn := TPdfDiscreteUniform.create( 1, 6, UUnitless );
      fn.dbField := integer( DEMOPdf2 );
      fn.name := 'Probability density function #2';
      fn.id := 2;

      item := TFunctionDictionaryItem.create( fn );
      item.new := true;
      _fnDictionary.insert( fn.name, item );

      _model.pdf2Name := fn.name;
    end
  ;


  function TDemoSimInput.validate( err: PString = nil ): boolean;
    begin
      result := _model.validate( err );

      if( 1 > _simIterations ) then
        begin
          result := false;
          if( nil <> err ) then err^ := err^ + tr( 'Number of iterations is not specified.' ) + endl;
        end
      ;

      if( false = result ) then
        begin
          if( nil <> err ) then err^ := tr( 'Simulation parameters are not valid:' ) + endl + err^ + endl;
        end
      ;
    end
  ;


  procedure TDemoSimInput.setUpdated( val: boolean );
    begin
      setLength( _output, 0 );

      inherited setUpdated( val );
    end
  ;


  procedure TDemoSimInput.run( fn: TObjFnVoid0 = nil );
    var
      i: integer;
    begin
      // Clear any old output, and prepare for new
      setLength( _output, 0 );
      setLength( _output, _simIterations );

      //setRngSeed( 7 ); // For testing purposes

      // Run the model
      for i := 0 to _simIterations - 1 do
        begin
          model.run();
          _output[i] := model.result;
        end
      ;
    end
  ;
  
  
end.

